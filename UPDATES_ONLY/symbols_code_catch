###   ONLY RUN THIS CODE ON AN AS NEEDED BASIS
###   THIS WILL DOWNLOAD ALL SET IMAGES THROUGH API
###   AND OVERWRITE EXISTING FILES.



## TODO: when saving the files- some special characters are being used in the save name causing problems
## in additional iterations.



import requests
import os
import cv2

# Base URL
url = "https://api.pokemontcg.io/v2/sets"

# Header with API key (replace with your actual API key)
headers = {
    "X-Api-Key": "b97ddab5-5569-4912-91b7-a3a93776f78d",  # Use the appropriate key
    "Content-Type": "application/json"
}

# Make the GET request to fetch all sets
response = requests.get(url, headers=headers)

# Check the response status
if response.status_code == 200:
    # Parse JSON data
    data = response.json()

    # Extract the "symbol" URLs from the "data"
    sets = data.get("data", [])  # If the response has multiple sets, it might be a list
    

    named_symbols = [{"name": s["name"], "symbol_url": s["images"]["symbol"]} for s in sets]

    # Print extracted symbol URLs
    print("Set Symbols:", len(named_symbols))
else:
    print(f"Failed to fetch sets. Status code: {response.status_code}")
    print("Response:", response.text)


# Download the set symbols into "images\set_symbols"

# Directory to save the images
output_directory = "images\\set_symbols"

# Ensure the directory exists
os.makedirs(output_directory, exist_ok=True)

# Iterate through the named symbols and download each image
for i, symbol in enumerate(named_symbols, start=1):
    try:
        # Extract name and URL from the dictionary
        filename = f"{symbol['name']}.png"  # Add .png extension to name
        url = symbol["symbol_url"]
        
        # Send a GET request to fetch the image content
        response = requests.get(url, stream=True)
        if response.status_code == 200:
            # Full path to save the image
            file_path = os.path.join(output_directory, filename)

            if not os.path.exists(file_path):
            
                # Write the image content to the file
                with open(file_path, "wb") as f:
                    for chunk in response.iter_content(chunk_size=1024):
                        f.write(chunk)
                print(f"Downloaded: {filename} -> {file_path}")
        else:
            print(f"Failed to download {url}. HTTP status code: {response.status_code}")
    except Exception as e:
        print(f"Error downloading {symbol['name']} ({url}): {e}")


# Resize and overwrite the file images
# def resize_and_overwrite_images(folder_path, target_size=(40, 40)):
#     """
#     Resize all images in the specified folder to the target size and overwrite the original files.

#     :param folder_path: Path to the folder containing the images.
#     :param target_size: Tuple specifying the desired size (width, height) in pixels.
#     """
#     if not os.path.exists(folder_path):
#         print(f"Folder not found: {folder_path}")
#         return

#     # Loop through all files in the folder
#     for file_name in os.listdir(folder_path):
#         file_path = os.path.join(folder_path, file_name)

#         # Check if the file is an image
#         if file_name.lower().endswith((".png", ".jpg", ".jpeg")):
#             try:
#                 # Read the image
#                 image = cv2.imread(file_path)

#                 # Check if the image was loaded successfully
#                 if image is None:
#                     print(f"Failed to read image: {file_path}")
#                     continue

#                 # Resize the image
#                 resized_image = cv2.resize(image, target_size, interpolation=cv2.INTER_AREA)

#                 # Overwrite the original file with the resized image
#                 cv2.imwrite(file_path, resized_image)
#                 print(f"Resized and overwrote: {file_name}")

#             except Exception as e:
#                 print(f"Error processing file {file_name}: {e}")

#     print("Resizing complete!")

# Call the function to resize images
# resize_and_overwrite_images(output_directory)


